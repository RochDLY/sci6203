<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.1.189">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Yann Audin">
<meta name="dcterms.date" content="2022-11-20">

<title>SCI6203 - Revue de littérature : Mikolov et al.</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1.6em;
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit"
  }
}</script>

  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">SCI6203</span>
    </a>
  </div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html">À propos</a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/RochDLY/sci6203"><i class="bi bi-github" role="img">
</i> 
 </a>
  </li>  
</ul>
              <div id="quarto-search" class="" title="Search"></div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">Revue de littérature : Mikolov et al.</h1>
                                <div class="quarto-categories">
                <div class="quarto-category">journal</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Yann Audin </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">November 20, 2022</p>
      </div>
    </div>
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Court résumé de l’article de Mikolov, Tomas et al.</p>
<p><img src="anthalgo.jpg" class="img-fluid"></p>
<section id="efficient-estimation-of-word-representations-in-vector-space" class="level2">
<h2 class="anchored" data-anchor-id="efficient-estimation-of-word-representations-in-vector-space">Efficient Estimation of Word Representations in Vector Space</h2>
<p>La librairie Word2Vec et la vectorisation de mots sont le résultat d’une démarche téléologique précisée à même le titre de cet article : l’approximation d’une représentation vectorielle des mots (ou formes) <em>qui soit efficace</em>. Dans un contexte de recherche d’une intelligence artificielle générale (voir GPT-3 et LaMDA), cette intention, mise de l’avant par Mikolov et ses collègues doit servir rappel des contraintes épistémologiques de leur démarche : la vectorisation de mots ne génère pas un objet mathématique qui représente la sémantique de ce dernier. Plutôt, la vectorisation de mot donne une approximation dans un espace vectoriel de l’utilisation normale d’une forme en fonction de plusieurs paramètres, le premier étant nommé le contexte. Ce paramètre décrit combien de formes seront considérés à la fois, car Word2Vec considère chaque formes en fonction de celles qui l’entourent dans le corpus ; le contexte est une valeur entière qui exprime combien de formes sont considérés avant et après chaque forme. L’algorithme de Word2Vec minimise une fonction de perte selon l’une des deux architectures choisies ; la première, <em>Continuous Bag of Word</em> (CBOW) utilise un réseau de neurones pour prédire quel terme est le plus probable à trouver en fonction d’un contexte donné, puis vérifie sa prédiction en fonction du texte. À l’inverse, le <em>Skip-gram</em> prédit quels formes feront partie du contexte à partir d’un terme, puis corrige en fonction de la réponse correcte tirée du corpus. Cet algorithme entraîne son réseau de neurones sur chaque forme (et contexte) du corpus un nombre de fois (<em>epoch</em>) choisi par l’utilisateur</p>
<p>La vectorisation de mot est une méthode rendue possible par la disponibilité de corpus massifs (dont le nombre de formes se compte en milliards) et fonctionne à partir de plusieurs présuppositions :</p>
<ol type="1">
<li>La linguistique distributionnelle : il est possible d’inférer le sens des mots à partir de leur position et distribution dans des textes;</li>
<li>La régularité sémantique : les mots ayant des sens semblables auront des vecteurs ayant plusieurs degrés de similarité;</li>
<li>La similarité syntaxique : les mots étant utilisés de manière similaire auront des vecteurs ayant plusieurs degrés de similarité.</li>
</ol>
<p>Une importante découverte de ce modèle est que, pour un corpus assez grand, ces vecteurs ont des propriétés additives intéressantes. L’exemple cité par les auteurs est le suivant : <span class="math inline">\(\overrightarrow{King} - \overrightarrow{Man} + \overrightarrow{Woman} \approx \overrightarrow{Queen}\)</span>. En d’autres mots, il existe une certaine cohérence dans l’espace vectoriel produit, ce dernier encode les similarités syntaxiques et sémantiques sous la forme de distances plus courtes entre deux formes similaires, mais aussi les translations sémantiques. Ainsi, une paire de mots dont la différence vectorielle est la même que pour une autre paire de mots dénote une relation sémantique similaire. C’est d’ailleurs l’une des deux manières par laquelle les auteurs évaluent leurs modèles : testant sa capacité à produire des listes de paires de mots sémantiquement liés, par exemple des pays et leurs capitales ou devises. Leur autre outil d’évaluation des modèles est syntaxique, ils y testent des paires comme celles des adjectifs et leurs adverbes, ou un mot et son contraire. Les modèles proposés par les auteurs dépassent 50% de précision à ces tests, les auteurs précisent que de plus gros modèles (avec des vecteurs et corpus plus imposants) seront sans doute en mesure de présenter de meilleurs résultats.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    target: function(trigger) {
      return trigger.previousElementSibling;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    setTimeout(function() {
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const cites = ref.parentNode.getAttribute('data-cites').split(' ');
    tippyHover(ref, function() {
      var popup = window.document.createElement('div');
      cites.forEach(function(cite) {
        var citeDiv = window.document.createElement('div');
        citeDiv.classList.add('hanging-indent');
        citeDiv.classList.add('csl-entry');
        var biblioDiv = window.document.getElementById('ref-' + cite);
        if (biblioDiv) {
          citeDiv.innerHTML = biblioDiv.innerHTML;
        }
        popup.appendChild(citeDiv);
      });
      return popup.innerHTML;
    });
  }
});
</script>
</div> <!-- /content -->



</body></html>